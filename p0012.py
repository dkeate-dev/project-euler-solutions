# Copyright 2023, Dustin Keate, All rights reserved.

# Highly Divisible Triangular Numbers

# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle
# number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# Let us list the factors of the first seven triangle numbers:
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
# What is the value of the first triangle number to have over five hundred divisors?



# TODO 1. starting with n = 1, increment each multiple of n above
# TODO 2. maybe tuple? true/false to mark natural numbers
# TODO 3. combine the two is some magical way that makes it all run about a billion times faster.
# TODO 4. Probably just keep going until 500, then check if it is a triangle number. This is probably slower that the opposite. AFTER TESTING, THIS IS VERY BAD.
# TODO 5. generate and check natural numbers. way less memory too. STILL BAD
# TODO 6. Find a better divisor counter. https://www.geeksforgeeks.org/count-divisors-n-on13/ What is this trickery?
# TODO 7. I'm dumb, just take it down to sqrt(), not cubed root.

#data = [0] * 10000000 # increase multiplier as necessary

#for i in range(1, len(data)):
#  for j in range(i, len(data), i):
#    data[j] += 1
#    if data[j] >= 500:
#      print(str(j) + ": " + str(data[j]))


#def num_of_divisors(num):
#  result = 0
#  for i in range(1, num+1):
#    if num%i == 0:
#      result += 1
#
#  return result

import math


def count_divisors(num):
  result = 0
  for i in range(1, math.isqrt(num)+1):
    if num%i == 0:
      if num/i == i:
        result += 1
      else:
        result += 2

  return result


next_triangle_num = 0

for i in range (1, 100000000):
  next_triangle_num += i
  if count_divisors(next_triangle_num) >= 500:
    print(next_triangle_num)
